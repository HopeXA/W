{"file_contents":{"MudaeAutoBot.py":{"content":"# -*- coding: utf-8 -*-\nimport discum\nimport re\nimport asyncio\nimport json\nimport time\nimport logging\nimport threading\nfrom os.path import join as pathjoin\nfrom discum.utils.slash import SlashCommander\nfrom discum.utils.button import Buttoner\nfrom collections import OrderedDict\n\nclass CacheDict(OrderedDict):\n    def __init__(self, *args, **kwds):\n        self.max = kwds.pop(\"max\", None)\n        OrderedDict.__init__(self, *args, **kwds)\n        self._check_size_limit()\n\n    def __setitem__(self, key, value):\n        OrderedDict.__setitem__(self, key, value)\n        self._check_size_limit()\n\n    def _check_size_limit(self):\n        if self.max is not None:\n            while len(self) > self.max:\n                self.popitem(last=False)\n\nmsg_buf = CacheDict(max=50)\n\njsonf = open(\"Settings_Mudae.json\")\nsettings = json.load(jsonf)\njsonf.close()\n\nbot = discum.Client(token=settings[\"token\"],log={\"console\":False, \"file\":False})\nmudae = 432610292342587392\n\nwith open(\"cmds.txt\",\"r\") as f:\n    mudae_cmds = [line.rstrip() for line in f]\nmhids = [int(mh) for mh in settings[\"channel_ids\"]]\nshids = [int(sh) for sh in settings[\"slash_ids\"]]\nghids = [int(gh) for gh in settings[\"slash_guild_ids\"]]\nchannel_settings = dict()\n\nseries_list = settings[\"series_list\"]\nchars = [charsv.lower() for charsv in settings[\"namelist\"]]\nkak_min = settings[\"min_kak\"]\nroll_prefix = settings[\"roll_this\"]\nsniping = settings.get(\"sniping_enabled\",True)\n\nready = bot.gateway.READY\n\nmention_finder = re.compile(r'\\<@(?:!)?(\\d+)\\>')\npagination_finder = re.compile(r'\\d+ / \\d+')\n\nkak_finder = re.compile(r'\\*\\*??([0-9]+)\\*\\*<:kakera:469835869059153940>')\nlike_finder = re.compile(r'Likes\\: \\#??([0-9]+)')\nclaim_finder = re.compile(r'Claims\\: \\#??([0-9]+)')\npoke_finder = re.compile(r'\\*\\*(?:([0-9+])h )?([0-9]+)\\*\\* min')\nwait_finder = re.compile(r'\\*\\*(?:([0-9+])h )?([0-9]+)\\*\\* min \\w')\nwaitk_finder = re.compile(r'\\*\\*(?:([0-9+])h )?([0-9]+)\\*\\* min')\nser_finder = re.compile(r'.*.')\n\nKakeraVari = [kakerav.lower() for kakerav in settings[\"emoji_list\"]]\n#soulLink = [\"kakeraR\",\"KakeraO\"]\neventlist = [\"🕯️\",\"😆\"]\n\n#Last min Claims\nis_last_enable = True if settings[\"Last_True\"].lower().strip() == \"true\" else False \nlast_claim_window = settings[\"last_claim_min\"]\nmin_kak_last = settings[\"min_kak_last_min\"]\n\nkakera_wall = {}\nwaifu_wall = {}\n\n#logging settings\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)\nformatter = logging.Formatter('%(asctime)s:%(message)s')\nstream_handler = logging.StreamHandler()\nstream_handler.setFormatter(formatter)\nlogger.addHandler(stream_handler)\n\ndef get_kak(text):\n    k_value = kak_finder.findall(text)\n    like_value = like_finder.findall(text)\n    claim_value=claim_finder.findall(text)\n    if len(k_value):\n        return k_value[0]\n    elif len(like_value) or len(claim_value):\n        LR = 0\n        CR = 0 \n        CA= 1\n        if(len(like_value)):\n            LR = like_value[0]\n        if(len(claim_value)):\n            CR = claim_value[0]\n        pkak = (int(LR) + int(CR)) /2\n        multi = 1 + (CA/5500)\n        return((25000 *(pkak+70)**-.75+20)*multi+.5)     \n    return 0\n    \ndef get_wait(text):\n    waits = wait_finder.findall(text)\n    if len(waits):\n        hours = int(waits[0][0]) if waits[0][0] != '' else 0\n        return (hours*60+int(waits[0][1]))*60\n    return 0\n    \ndef get_pwait(text):\n    waits = poke_finder.findall(text)\n    if len(waits):\n        hours = int(waits[0][0]) if waits[0][0] != '' else 0\n        return (hours*60+int(waits[0][1]))*60\n    return 0\ndef get_serial(text):\n    serk = ser_finder.findall(text)\n    return serk[0]\n\n_resp = dict()\ndef wait_for(bot, predicate, timeout=None):\n    ev = threading.Event()\n    ident = threading.get_ident()\n    def evt_check(resp):\n        if predicate(resp):\n            _resp[ident] = resp.parsed.auto()\n            ev.set()\n    bot.gateway._after_message_hooks.insert(0,evt_check)\n    ev.wait(timeout)\n    bot.gateway.removeCommand(evt_check)\n    obj = _resp.pop(ident,None)\n    \n    return obj\n\ndef mudae_warning(tide,StartwithUser=True):\n    # build check func\n    def c(r):\n        if r.event.message:\n            r = r.parsed.auto()\n            # must be from relevant channel id, and start with username\n            if StartwithUser == True:\n                return r['author']['id'] == str(mudae) and r['channel_id'] == tide and r['content'].startswith(f\"**{bot.gateway.session.user['username']}\")\n            elif StartwithUser == False:\n                return r['author']['id'] == str(mudae) and r['channel_id'] == tide\n        return False\n    return c\n\ndef get_server_settings(guild_id,channel_id):\n    try:\n        #with open(f\"channeldata\\\\{channel_id}.txt\",\"r\") as textsettings:\n        with open(pathjoin('channeldata',f'{channel_id}.txt'),'r') as textsettings:\n            print(f\"Reading from File for channel {channel_id}\")\n            return textsettings.read()\n    except IOError:\n        print(f\"File Not Found using Different Method\")\n        \n    \n    msgs = bot.searchMessages(guild_id,authorID=[mudae],textSearch=\"($togglehentai)\",limit = 5)\n    Rmsgs = bot.filterSearchResults(msgs)\n    for group in Rmsgs:\n        if group['content'].startswith(\"🛠️\"):\n            print(f\"Using $settings found during search for channel {channel_id}\")\n            abcdef = group['content'].replace(\"🛠️\",\"_\").replace(\"⭐\",\"_\")\n            #pres_data = open(f\"channeldata\\\\{channel_id}.txt\",\"w+\")\n            pres_data = open(pathjoin('channeldata',f'{channel_id}.txt'),'w+')\n            pres_data.write(abcdef)\n            pres_data.close()\n            return group['content']\n    # msgs = bot.searchMessages(guild_id,userID=[mudae],textSearch=\"($togglehentai)\").json()['messages']\n    # for group in msgs:\n        # for result in group:\n            # if 'hit' in result:\n                # if result['content'].startswith(\"🛠️\"):\n                    # print(result)\n                    # return result['content']\n    \n    # no setting found\n    # so send settings request, and hope they have default prefix.\n    FsMsgs = bot.searchMessages(guild_id,channelID=[channel_id],authorID=[bot.gateway.session.user['id']],textSearch=roll_prefix,includeNsfw=True,limit=2)\n    FsResults = bot.filterSearchResults(FsMsgs)\n    for group in FsResults:\n        if group['content'].endswith(roll_prefix):\n            settings_hope_prefix = group['content'].split(roll_prefix)[0]\n             \n    print(f\"Default $settings used for channel {channel_id}\")\n    default_settings_if_no_settings = f\"\"\"🛠️ __**Server Settings**__ 🛠️\n                 (Server not premium)\n\n                · Prefix: **{settings_hope_prefix}** ($prefix)\n                · Lang: **en** ($lang)\n                · Claim reset: every **180** min. ($setclaim)\n                · Exact minute of the reset: xx:**56** ($setinterval)\n                · Reset shifted: by +**0** min. ($shifthour)\n                · Rolls per hour: **10** ($setrolls)\n                · Time before the claim reaction expires: **30** sec. ($settimer)\n                · Spawn rarity multiplicator for already claimed characters: **2** ($setrare)\n                · Server game mode: **1** ($gamemode)\n                · This channel instance: **1** ($channelinstance)\n                · Slash commands: enabled ($toggleslash)\n\n                · Ranking: enabled ($toggleclaimrank/$togglelikerank)\n                · Ranks displayed during rolls: claims and likes ($togglerolls)\n                · Hentai series: enabled ($togglehentai)\n                · Disturbing imagery series: enabled ($toggledisturbing)\n                · Rolls sniping: **2** ($togglesnipe) => **{settings['claim_delay']}** sec.\n                · Kakera sniping: **1** ($togglekakerasnipe) => **{settings['kak_delay']}** sec.\n                · Limit of characters per harem: **8100** ($haremlimit)\n                · Custom reactions: yes ($claimreact list)\n\n                · Kakera trading: **disabled** ($togglekakeratrade)\n                · Kakera calculation: claims and likes ranks (and number of claimed characters) ($togglekakeraclaim/$togglekakeralike)\n                · Kakera value displayed during rolls: enabled ($togglekakerarolls)\n                · $kakeraloot wishprotect: enabled ($togglewishprotect)\"\"\"            \n    return default_settings_if_no_settings\n\ndef parse_settings_message(message):\n    if message == None:\n        return None\n    val_parse = re.compile(r'\\*\\*(\\S+)\\*\\*').findall\n    num_parse = re.compile(r'(\\d+)').findall\n    num_parsedec = re.compile(r'(\\d*[.,]?\\d+)').findall\n\n    settings_p = re.findall(r'\\w+: (.*)',message)\n    settings = dict()\n\n    settings['prefix'] = val_parse(settings_p[0])[0]\n    settings['prefix_len'] = len(settings['prefix'])\n    settings['claim_reset'] = int(num_parse(settings_p[2])[0]) # in minutes\n    settings['reset_min'] = int(num_parse(settings_p[3])[0])\n    settings['shift'] = int(num_parse(settings_p[4])[0])\n    settings['max_rolls'] = int(num_parse(settings_p[5])[0])\n    settings['expiry'] = float(num_parse(settings_p[6])[0])\n    settings['claim_snipe'] = [float(v) for v in num_parsedec(settings_p[17])]\n    settings['kak_snipe'] = [float(v) for v in num_parsedec(settings_p[18])]\n    \n\n    settings['claim_snipe'][0] = int(settings['claim_snipe'][0])\n    # pad out claim/kak snipe for default '0 second cooldown'\n    if len(settings['claim_snipe']) < 2:\n        settings['claim_snipe'] += [0.0]\n    if len(settings['kak_snipe']) < 2:\n        settings['kak_snipe'] += [0.0]\n    settings['claim_snipe'][0] = int(settings['claim_snipe'][0])\n    settings['kak_snipe'][0] = int(settings['kak_snipe'][0])\n\n    settings['pending'] = None\n    settings['rolls'] = 0\n \n    return settings\n\ndef get_snipe_time(channel,rolled,message):\n    # Returns delay for when you are able to snipe a given roll\n    r,d = channel_settings[channel]['claim_snipe']\n    if r == 0:\n        # Anarchy FTW!\n        return 0.0\n    \n    global user\n    is_roller = (rolled == user['id'])\n    if (r < 4 or r == 5) and is_roller:\n        # Roller can insta-snipe\n        return 0.0\n    if r == 2 and not is_roller:\n        # Not the roller.\n        return d\n    \n    wished_for = mention_finder.findall(message)\n    \n    # Wish-based rules\n    if not len(wished_for):\n        # Not a WISHED character\n        if r > 4:\n            # Combined restriction, roller still gets first dibs\n            return 0.0 if is_roller else d\n        return 0.0\n\n    if r > 2 and user['id'] in wished_for:\n        # Wishers can insta-snipe\n        return 0.0\n    \n    if r == 1 and rolled not in wished_for:\n        # Roller (who is not us) did not wish for char, so can insta-snipe\n        return 0.0\n    \n    return d\n\ndef next_claim(channel):\n    channel = int(channel)\n    offset = (120-(channel_settings[channel]['shift']+channel_settings[channel]['reset_min']))*60\n    \n    reset_period = channel_settings[channel]['claim_reset']*60\n    t = time.time()+offset\n    last_reset = (t%86400)%reset_period\n    reset_at = reset_period-last_reset+time.time()\n\n    return (int(t/reset_period),reset_at) # claim window id, timestamp of reset\n\ndef next_reset(channel):\n    # Returns timestamp of next reset\n    channel = int(channel)\n    offset = channel_settings[channel]['reset_min']*60\n    t = time.time()\n    return t+(3600-((t-offset)%3600))\n\ndef poke_roll(tide):\n    logger.debug(f\"Pokemon Rolling Started in channel {tide}. (If you would like this in a different channel, please configure the desired channel ID as the first in your list)\")\n    tides = str(tide)\n    if tide not in channel_settings:\n        logger.error(f\"Could not find channel {tide}, will not roll poke\")\n        return\n    c_settings = channel_settings[tide]\n    pwait = 0\n    while True:\n        while pwait == 0:\n            time.sleep(2)\n            bot.sendMessage(tides,c_settings['prefix']+\"p\")\n            pwait = 2*60*60 # sleep for 2 hours\n        print(f\"{pwait} : pokerolling : {tide}\")\n        time.sleep(pwait) \n        pwait = 0\n        \ndef daily_roll(tide):\n    logger.debug(f\"Daily Rolling Started in channel {tide}. (If you would like this in a different channel, please configure the desired channel ID as the first in your list)\")\n    tides = str(tide)\n    if tide not in channel_settings:\n        logger.error(f\"Could not find channel {tide}, will not roll Daily\")\n        return\n    c_settings = channel_settings[tide]\n    dwait = 0\n    while True:\n        while dwait == 0:\n            time.sleep(2)\n            bot.sendMessage(tides,c_settings['prefix']+\"daily\")\n            dwait = 20*60*60 # sleep for 2 hours\n        print(f\"{dwait} : daily_rolling : {tide}\")\n        time.sleep(dwait) \n        dwait = 0\n        \ndef waifu_roll(tide,slashed,slashguild):\n    global user\n    if slashed == None:\n        logger.debug(f\"waifu rolling Started in channel {tide}\")\n    else:\n        logger.debug(f\"Slashed rolling Started in channel {tide}\")\n    \n    tides = str(tide)\n    waifuwait = 0\n    \n    if tide not in channel_settings:\n        logger.error(f\"Could not find channel {tide}, skipping waifu roll on this channel.\")\n        return\n    \n    c_settings = channel_settings[tide]\n    roll_cmd = c_settings['prefix'] + roll_prefix\n    \n    warned_overroll = False\n    while True:\n        wait_for_quiet = wait_for(bot,mudae_warning(tides,False),timeout=10)\n        if wait_for_quiet != None:\n            # don't do stuff\n            continue\n    \n        c_settings['rolls'] = 0\n        rolls_left = -1\n        while waifuwait == False:\n            if slashed != None:\n                bot.triggerSlashCommand(str(mudae), channelID=tides, guildID=slashguild, data=slashed)\n            else:\n                bot.sendMessage(tides,roll_cmd)\n            rolls_left = rolls_left-1\n            \n            varwait = wait_for(bot,mudae_warning(tides,False),timeout=5)\n            time.sleep(.5)\n            \n            if varwait != None and varwait['content'].startswith(f\"**{bot.gateway.session.user['username']}\") and \"$ku\" not in varwait['content']:\n                # We over-rolled.\n                waifuwait = True\n                if c_settings['rolls'] > 2 and not warned_overroll:\n                    # We overrolled when we shouldn't have. Warn the user they can prevent this\n                    warned_overroll = True\n                    logger.warning(\"Please enable $rollsleft 0 feature to prevent overrolling\")\n                break\n            elif varwait != None and rolls_left < 0:\n                # Check if our roll featured a warning\n                total_text = varwait.get('content','') # $rollsleft 2\n                if len(varwait['embeds']):\n                    total_text += varwait['embeds'][0].get('footer',{}).get('text','') # $rollsleft 0 (default)\n                    total_text += varwait['embeds'][0].get('description','') # $rollsleft 1\n                \n                # Check if it's our roll\n                our_roll = msg_buf.get(varwait['id'],{}).get('rolled',None)\n                p = c_settings['pending']\n                if our_roll == None and p:\n                    # on_message may have not seen our roll, so we should manually check if it was our roll\n                    our_roll = p == bot.gateway.session.user['id']\n                    \n                    \n                if our_roll and \"\\u26a0\\ufe0f 2 ROLLS \" in total_text:\n                    # Has warning for us\n                    rolls_left = 2\n            if rolls_left == 0:\n                # Ran out of rolls\n                waifuwait = True\n            \n        print(f\"{waifuwait}: Waifu rolling : {tide}\")\n        time.sleep((next_reset(tide)-time.time())+1)\n        waifuwait = False\n\ndef snipe(recv_time,snipe_delay):\n    if snipe_delay != 0.0:\n        try:\n            time.sleep((recv_time+snipe_delay)-time.time())\n        except ValueError:\n            # sleep was negative, so we're overdue!\n            return\n    time.sleep(.5)\n    \ndef snipe_intent(messagechunk,mreacter,buttonspres):\n    if \"reactions\" in mreacter:\n        if mreacter[\"reactions\"][0][\"emoji\"]['id'] == None:\n            bot.addReaction(messagechunk[\"channel_id\"], messagechunk[\"id\"], mreacter[\"reactions\"][0][\"emoji\"][\"name\"])\n        elif mreacter[\"reactions\"][0][\"emoji\"]['id'] != None and \"kakera\" not in mreacter[\"reactions\"][0][\"emoji\"][\"name\"]:\n            cust_emoji_send = mreacter[\"reactions\"][0][\"emoji\"][\"name\"] + \":\" + mreacter[\"reactions\"][0][\"emoji\"]['id']\n            bot.addReaction(messagechunk['channel_id'], messagechunk['id'], cust_emoji_send)\n    elif buttonspres.components != [] :\n        buttMojis = buttonspres.components[0][\"components\"][0][\"emoji\"][\"name\"]\n        if \"kakera\" not in buttMojis:\n            bot.click(\n                messagechunk['author']['id'],\n                channelID=messagechunk[\"channel_id\"],\n                guildID=messagechunk.get(\"guild_id\"),\n                messageID=messagechunk[\"id\"],\n                messageFlags=messagechunk[\"flags\"],\n                data=buttonspres.getButton(emojiName=buttMojis),\n                )  \n    else:\n        bot.addReaction(messagechunk['channel_id'], messagechunk['id'], \"❤\")\n\ndef is_rolled_char(m):\n    embeds = m.get('embeds',[])\n    if len(embeds) != 1 or \"image\" not in embeds[0] or \"author\" not in embeds[0] or list(embeds[0][\"author\"].keys()) != ['name']:\n        # not a marry roll.\n        return False\n    elif 'footer' in embeds[0] and 'text' in embeds[0]['footer'] and pagination_finder.findall(embeds[0]['footer']['text']):\n        # Has pagination e.g. \"1 / 29\", which does not occur when rolling\n        return False\n    return True\n\n@bot.gateway.command\ndef on_message(resp):\n    global user\n    recv = time.time()\n    if resp.event.message:\n        m = resp.parsed.auto()\n        #print(m)\n        aId = m['author']['id']\n        content = m['content']\n        embeds = m['embeds']\n        messageid = m['id']\n        channelid = m['channel_id']\n        \n        guildid = m['guild_id'] if 'guild_id' in m else None\n        butts = Buttoner(m[\"components\"])\n        \n        #print(dir(butts))\n        \n        # if \"@\" in content:\n            # print(\"There was a possible wish detected\")\n        \n        # if butts.components != [] :\n            # buttMoji = butts.components[0][\"components\"][0][\"emoji\"][\"name\"]\n            # bot.click(\n            # aId,\n            # channelID=m[\"channel_id\"],\n            # guildID=m.get(\"guild_id\"),\n            # messageID=m[\"id\"],\n            # messageFlags=m[\"flags\"],\n            # data=butts.getButton(emojiName=buttMoji),\n            # )\n            \n        if int(channelid) not in mhids:\n            # Not a channel we work in.\n            return\n        \n        if int(channelid) not in channel_settings:\n            mhids.remove(int(channelid))\n            logger.error(f\"Could not find settings for {channelid}, please trigger the '$settings' command in the server and run the bot again.\")\n            return\n        c_settings = channel_settings[int(channelid)]\n\n        if c_settings['pending'] == None and int(aId) != mudae and content[0:c_settings['prefix_len']] == c_settings['prefix'] and content.split(' ')[0][c_settings['prefix_len']:] in mudae_cmds:\n            # Note rolls as they happen so we know who rolled what\n            c_settings['pending'] = aId\n            return\n        \n        elif int(aId) == mudae:\n            if \"interaction\" in m:\n                # Mudae triggered via slash command\n                roller = m['interaction']['user']['id']\n            else:\n                roller = c_settings['pending']\n            c_settings['pending'] = None\n            # Validate this is a rolled character.\n            if not is_rolled_char(m):\n                # Might be claim timer\n                if m['content'].startswith('<@' + user['id'] + '>') or m['content'].startswith('<@!' + user['id'] + '>'):\n                    # get claim time\n                    if get_pwait(m['content']):\n                        waifu_wall[channelid] = next_claim(channelid)[0]\n                return\n          \n            \n            msg_buf[messageid] = {'claimed':int(embeds[0].get('color',0)) not in (16751916,1360437),'rolled':roller == user['id']}\n            print(f\"Our user rolled in {channelid}\" if roller == user['id'] else f\"Someone else rolled in {channelid}\")\n            if msg_buf[messageid]['claimed']:\n                return\n            if(not sniping and roller != user['id']):\n                # Sniping disabled by user\n                return\n            \n            if roller == user['id']:\n                # confirmed user roll\n                c_settings['rolls'] += 1\n            \n            if waifu_wall.get(channelid,0) != next_claim(channelid)[0]:\n                snipe_delay = get_snipe_time(int(channelid),roller,content)\n                charpop = m['embeds'][0]\n                charname = charpop[\"author\"][\"name\"]\n                chardes = charpop[\"description\"]\n                charcolor = int(charpop['color'])\n\n                if str(user['id']) in content:\n                    logger.info(f\"Wished {charname} from {get_serial(chardes)} with {get_kak(chardes)} Value in Server id:{guildid}\")\n                    snipe(recv,snipe_delay)\n                    if msg_buf[messageid]['claimed']:\n                        return\n                    m_reacts = bot.getMessage(channelid, messageid).json()[0]\n                    snipe_intent(m,m_reacts,butts)\n                    # if \"reactions\" in m_reacts:\n                        # if m_reacts[\"reactions\"][0][\"emoji\"]['id'] == None:\n                            # bot.addReaction(channelid, messageid, m_reacts[\"reactions\"][0][\"emoji\"][\"name\"])\n                        # elif m_reacts[\"reactions\"][0][\"emoji\"]['id'] != None and \"kakera\" not in m_reacts[\"reactions\"][0][\"emoji\"][\"name\"]:\n                            # cust_emoji_sen = m_reacts[\"reactions\"][0][\"emoji\"][\"name\"] + \":\" + m_reacts[\"reactions\"][0][\"emoji\"]['id']\n                            # bot.addReaction(channelid, messageid, cust_emoji_sen)\n                    # elif butts.components != [] :\n                        # buttMoji = butts.components[0][\"components\"][0][\"emoji\"][\"name\"]\n                        # if \"kakera\" not in buttMoji:\n                            # bot.click(\n                                        # aId,\n                                        # channelID=m[\"channel_id\"],\n                                        # guildID=m.get(\"guild_id\"),\n                                        # messageID=m[\"id\"],\n                                        # messageFlags=m[\"flags\"],\n                                        # data=butts.getButton(emojiName=buttMoji),\n                                        # )  \n                    # else:\n                        # bot.addReaction(channelid, messageid, \"❤\")\n                \n                if charname.lower() in chars:\n                    \n                    logger.info(f\"{charname} appeared attempting to Snipe Server id:{guildid}\")\n                    snipe(recv,snipe_delay)\n                    if msg_buf[messageid]['claimed']:\n                        return\n                    m_reacts = bot.getMessage(channelid, messageid).json()[0]\n                    snipe_intent(m,m_reacts,butts)\n                \n                for ser in series_list:\n                    if ser in chardes and charcolor == 16751916:\n                        \n                        \n                        logger.info(f\"{charname} from {ser} appeared attempting to snipe in {guildid}\")\n                        snipe(recv,snipe_delay)\n                        if msg_buf[messageid]['claimed']:\n                            return\n                        m_reacts = bot.getMessage(channelid, messageid).json()[0]\n                        if \"reactions\" in m_reacts:\n                            if m_reacts[\"reactions\"][0][\"emoji\"]['id'] == None:\n                                bot.addReaction(channelid, messageid, m_reacts[\"reactions\"][0][\"emoji\"][\"name\"])\n                                break\n                            elif m_reacts[\"reactions\"][0][\"emoji\"]['id'] != None and \"kakera\" not in m_reacts[\"reactions\"][0][\"emoji\"][\"name\"]:\n                                cust_emoji_sen = m_reacts[\"reactions\"][0][\"emoji\"][\"name\"] + \":\" + m_reacts[\"reactions\"][0][\"emoji\"]['id']\n                                bot.addReaction(channelid, messageid, cust_emoji_sen)\n                                break\n                        elif butts.components != [] :\n                            buttMoji = butts.components[0][\"components\"][0][\"emoji\"][\"name\"]\n                            if \"kakera\" not in buttMoji:\n                                    bot.click(\n                                        aId,\n                                        channelID=m[\"channel_id\"],\n                                        guildID=m.get(\"guild_id\"),\n                                        messageID=m[\"id\"],\n                                        messageFlags=m[\"flags\"],\n                                        data=butts.getButton(emojiName=buttMoji),\n                                        ) \n                            break\n        \n                        else:\n                            bot.addReaction(channelid, messageid, \"❤\")\n                            break\n\n                if \"<:kakera:469835869059153940>\" in chardes or \"Claims:\" in chardes or \"Likes:\" in chardes:\n                    #det_time = time.time()\n                    kak_value = get_kak(chardes)\n                    if int(kak_value) >= kak_min and charcolor == 16751916:\n                        \n                        \n                        logger.info(f\"{charname} with a {kak_value} Kakera Value appeared Server:{guildid}\")\n                        snipe(recv,snipe_delay)\n                        if msg_buf[messageid]['claimed']:\n                            return\n                        m_reacts = bot.getMessage(channelid, messageid).json()[0]\n                        snipe_intent(m,m_reacts,butts)\n                        #print(f\"took this much {time.time() - det_time}\")\n                \n                if is_last_enable and next_claim(channelid)[1] - time.time() < (60 * last_claim_window):\n                    if \"<:kakera:469835869059153940>\" in chardes or \"Claims:\" in chardes or \"Likes:\" in chardes:\n                        #det_time = time.time()\n                        print(f\"Last Minute Claim was attempted\")\n                        kak_value = get_kak(chardes)\n                        if int(kak_value) >= min_kak_last and charcolor == 16751916:\n                            \n                            \n                            logger.info(f\"{charname} with a {kak_value} Kakera Value appeared Server:{guildid}\")\n                            snipe(recv,snipe_delay)\n                            if msg_buf[messageid]['claimed']:\n                                return\n                            m_reacts = bot.getMessage(channelid, messageid).json()[0]\n                            snipe_intent(m,m_reacts,butts)\n                            #print(f\"took this much {time.time() - det_time}\")\n                \n                \n                if str(user['id']) not in content and charname.lower() not in chars and get_serial(chardes) not in series_list and int(get_kak(chardes)) < kak_min:\n                    logger.debug(f\"Ignoring {charname} from {get_serial(chardes)} with {get_kak(chardes)} Kakera Value in Server id:{guildid}\")\n            if butts.components != []:\n                buttsonly = butts.components[0][\"components\"][0][\"emoji\"][\"name\"]\n                #print(buttsonly.lower())\n                if buttsonly in KakeraVari:\n                    bot.click(\n                    aId,\n                    channelID=channelid,\n                    guildID=m.get(\"guild_id\"),\n                    messageID=messageid,\n                    messageFlags=m[\"flags\"],\n                    data=butts.getButton(emojiName=buttonly),\n                    )  \n                \n    if resp.event.message_updated:\n        # Handle claims\n        r = resp.parsed.auto()\n        rchannelid = r[\"channel_id\"]\n        rmessageid = r[\"id\"]\n        #embeds = r['embeds']\n        embeds = r.get('embeds',[])\n\n        if int(rchannelid) not in mhids:\n            return\n        try:\n            if r['author']['id'] == str(mudae):\n                if not is_rolled_char(r):\n                    return\n                embed = embeds[0]\n                f = embed.get('footer')\n                if f and bot.gateway.session.user['username'] in f['text']:\n                    # Successful claim, mark waifu claim window as used\n                    waifu_wall[rchannelid] = next_claim(rchannelid)[0]\n                elif int(embed['color']) == 6753288:\n                    # Someone else has just claimed this, mark as such\n                    msg_buf[rmessageid]['claimed'] = True\n        except KeyError:\n            pass\n\n    if resp.event.reaction_added:\n        r = resp.parsed.auto()\n        #print(r)\n        reactionid = int(r['user_id'])\n        rchannelid = r[\"channel_id\"]\n        rmessageid = r[\"message_id\"]\n        rguildid = r[\"guild_id\"]\n        emoji = r[\"emoji\"][\"name\"]\n        emojiid = r[\"emoji\"]['id']\n\n        if int(rchannelid) not in mhids:\n            # Not a channel we work in.\n            return\n        \n        if int(rchannelid) not in channel_settings:\n            mhids.remove(int(rchannelid))\n            logger.error(f\"Could not find settings for {rchannelid}, please trigger the '$settings' command in the server and run the bot again.\")\n            return\n        \n        if reactionid == int(user['id']) and int(rchannelid) in mhids:\n            logger.info(f\"Sniping time waited Reaction was added\")\n\n        snipe_delay = channel_settings[int(rchannelid)]['kak_snipe'][1]\n        \n        if reactionid == mudae and int(rchannelid) in mhids:\n            \n            if emojiid != None and emoji == \"kakeraP\" and (snipe_delay == 0 or msg_buf[rmessageid]['rolled']):\n                sendEmoji = emoji + \":\" +emojiid\n                react_m = bot.getMessage(rchannelid, rmessageid).json()[0]['embeds'][0]\n                time.sleep(1)\n                bot.addReaction(rchannelid,rmessageid,sendEmoji)\n                \n            if emojiid != None and emoji.lower() in KakeraVari:\n                sendEmoji = emoji + \":\" +emojiid\n                react_m = bot.getMessage(rchannelid, rmessageid).json()[0]['embeds'][0]\n                \n                cooldown = kakera_wall.get(rguildid,0) - time.time()\n                if cooldown <= 1:\n                    logger.info(f\"{emoji} was detected on {react_m['author']['name']}:{get_serial(react_m['description'])} in Server: {rguildid}\")\n                    time.sleep(snipe_delay)\n                    bot.addReaction(rchannelid,rmessageid,sendEmoji)\n                else:\n                    logger.info(f\"Skipped {emoji} found on {react_m['author']['name']}:{get_serial(react_m['description'])} in Server: {rguildid}\")\n                    return \n\n                warn_check = mudae_warning(rchannelid)\n                kakerawallwait = wait_for(bot,lambda r: warn_check(r) and 'kakera' in r.parsed.auto()['content'],timeout=5)\n\n                if kakerawallwait != None:\n                    time_to_wait = waitk_finder.findall(kakerawallwait['content'])\n                else:\n                    time_to_wait = []\n                \n                if len(time_to_wait):\n                    timegetter = (int(time_to_wait[0][0] or \"0\")*60+int(time_to_wait[0][1] or \"0\"))*60\n                    print(f\"{timegetter} for kakera_wall was set for Server : {rguildid}\")\n                    kakera_wall[rguildid] = timegetter + time.time()\n                    \n            # if emojiid != None and emoji.lower() in soulLink:\n                # react_m = bot.getMessage(rchannelid, rmessageid).json()[0]['embeds'][0]\n                # fake = react_m.get('footer')\n                # if fake and bot.gateway.session.user['username'] in fake['text'] and \"<:chaoskey:690110264166842421>\" in react_m['description']:\n                    # sendEmoji = emoji + \":\" +emojiid\n                    # cooldown = kakera_wall.get(rguildid,0) - time.time()\n                    # if cooldown <= 1:\n                        # logger.info(f\"{emoji} was detected on {react_m['author']['name']}:{get_serial(react_m['description'])} in Server: {rguildid}\")\n                        # time.sleep(snipe_delay)\n                        # bot.addReaction(rchannelid,rmessageid,sendEmoji)\n                    # else:\n                        # logger.info(f\"Skipped {emoji} found on {react_m['author']['name']}:{get_serial(react_m['description'])} in Server: {rguildid}\")\n                        # return \n\n                    # warn_check = mudae_warning(rchannelid)\n                    # kakerawallwait = wait_for(bot,lambda r: warn_check(r) and 'kakera' in r.parsed.auto()['content'],timeout=5)\n\n                    # if kakerawallwait != None:\n                        # time_to_wait = waitk_finder.findall(kakerawallwait['content'])\n                    # else:\n                        # time_to_wait = []\n                    \n                    # if len(time_to_wait):\n                        # timegetter = (int(time_to_wait[0][0] or \"0\")*60+int(time_to_wait[0][1] or \"0\"))*60\n                        # print(f\"{timegetter} for kakera_wall was set for Server : {rguildid}\")\n                        # kakera_wall[rguildid] = timegetter + time.time()\n                    \n            if emojiid == None:\n                if emoji in eventlist:\n                    print(f\"{emoji} was detected in Server: {rguildid}\")\n                    time.sleep(snipe_delay)\n                    bot.addReaction(rchannelid,rmessageid,emoji)\n\n                    \n    if resp.event.guild_application_commands_updated:\n        slashCmds = resp.parsed.auto()['application_commands']\n        s = SlashCommander(slashCmds, application_id=str(mudae))\n        for sli in range(len(s.commands.get(\"options\"))):\n            if s.commands.get(\"options\")[sli].get(\"name\") == roll_prefix:\n                slashget = s.commands.get(\"options\")[sli]\n        #slashget = s.get([\"wa\"])\n        #print(slashget)\n        \n        if settings['slash_rolling'].lower().strip() == \"true\":\n            for xchg in range(len(shids)):\n                slashchannel = shids[xchg]\n                slashguild = ghids[xchg]\n                slashfus = threading.Timer(10.0,waifu_roll,args=[slashchannel,slashget,slashguild])\n                slashfus.start()\n            \n    global ready\n \n    if resp.event.ready_supplemental and not ready:\n        ready = bot.gateway.READY\n        try:\n            user = bot.gateway.session.user\n        except KeyError:\n            try:\n                with open(pathjoin('user','user.txt'),'r') as userssettings:\n                    print(f\"Reading from UserFile\")\n                    user = userssettings.read()\n            except IOError:\n                print(f\"File Not Found using Different Method\")\n        bot.gateway.request.searchSlashCommands(str(ghids[0]), limit=100, command_ids=[])\n        \n        try:\n            guilds = bot.gateway.session.settings_ready['guilds']\n        except KeyError:\n            print(\"It seems like you were unable to get all the guilds you are in please obtain your users settings\")\n            try:\n                with open(pathjoin('user','guild.txt'),'r') as guildersettings:\n                    print(\"reading from Guild file\")\n                    guilds = guildersettings.read()\n            except IOError:\n                print(\"Please get a dump of all your guilds and put it in the userfolder\")\n                \n        chs = set(str(mhid) for mhid in mhids)\n        for gid, guild in guilds.items():\n            for matched_channel in (set(guild['channels'].keys()) & chs):\n                # Find associated guild ID to a monitored channel, then get settings\n                msg = get_server_settings(gid,matched_channel)\n                c_settings = parse_settings_message(msg)\n                channel_settings[int(matched_channel)] = c_settings\n        \n        if settings['pkmrolling'].lower().strip() == \"true\":\n            p = threading.Thread(target=poke_roll,args=[mhids[0]])\n            p.start()\n            time.sleep(3)\n            d = threading.Thread(target=daily_roll,args=[mhids[0]])\n            d.start()\n        if settings['rolling'].lower().strip() == \"true\":\n            for chid in mhids:\n                waifus = threading.Timer(10.0,waifu_roll,args=[chid,None,None])\n                waifus.start()\n\ndef empty(*args,**kwargs):\n    return\n\n#bot.sendMessage = empty\n\nbot.gateway.run(auto_reconnect=True)\n","size_bytes":36763},"README.md":{"content":"Please Gif Star ?? Stars make me happy.  I'm open to design automation for other games (doesn't have to be a discord game) just let me know\n# Regards to the Bot (back to coding from sq1)\nI'm working on porting the the code to discord.py self currently this one has very few features. super basic only here to use the discord.py self library with button clicks \n\nIt is able to roll but you have to manually change the channel Id in the code only single channel for now\nbut kakera sniping it added again but also not fine tuned it will just grab whatever kakera is around \n\nHave to do testing and slowly update the project\n\n!!!!!!! IF YOU FORK THIS REPO PLEASE DO NOT PUSH A COMMIT WITH YOUR DISCORD USER TOKEN !!!!!!\n\nI personally have tried to email users that I have found that posted their token\n >>> If you have posted your token Please delete said fork and just refork this repo github has a histroy of commits and I can find your token if its posted so again I would like to state\n\n!!!!!!! IF YOU FORK THIS REPO PLEASE DO NOT PUSH A COMMIT WITH YOUR DISCORD USER TOKEN !!!!!!\n\n\n# Regarding Issue Creation\nLately I have been getting alot of **Issues** that is not based on problems with the bot but they regard `Python Enviroment Errors` I.E `discum module not found`/`discum not installed properly` I have attempted to help many users that have had this problem but it is very time consuming. Python Enviroment issues are not a problem with the **BOT** but how one has installed python this varies from user to user.There are archived issues where a user has had a enviroment issue and they have resolved it you can use that as a reference.\nIf these resources do not help there are plently of resources online to help you resolve your `Python Enviroment` Issue\n\n\n`FAQS`\n+ CMD closes instantly - Open with IDLE and run it and it should give you the reason that it closed\n+ JSON load error - https://jsonformatter.curiousconcept.com/# copy and paste your json file into the textbox and click validate\n+ Does it have `gateway` log data ? - Your using older version of Dis.c.u.m refer to their github: https://github.com/Merubokkusu/Discord-S.C.U.M\n+ How is bot suppose to look like in normal state - \n![image](https://user-images.githubusercontent.com/33008397/123542012-47927e00-d715-11eb-9bf9-26c78a9721d7.png)\n\n+ Claims / Bot didn't claim X character - Please make sure you have checked if the `bot has not claimed already within the claim window` , or that `someone else did not already claim X character before the snipe protection has expired`\n\n**Future Issues opened that do NOT deal with a Error with the BOT will be labeled accordingly and closed**\n\n# MudaeAutoBot\nMudaeAutoBot is a python bot that auto rolls and attempts to snipe Kakeras and Claims in Mudae\n\n# Features\n+ Snipes and claims Kakera in any Discord servers you're in that has Mudae#0807\n+ Kakera value sniping as long as kakera value can be determined (e.g. Like Rank, Claim Rank, ## Kakera)\n+ Maximizes rolls by tracking roll timers\n+ Waifu/Husbando rolling\n+ Pokeslot rolling\n+ Selective Kakera Reaction Snipes Features(Includes: Soulmate Kak sniping Feature)\n+ Mudae emoji reaction event sniping support\n\n## How it works\nAll this bot needs to work is your Discord _usertoken_ and the channel IDs that you want it to post in\n\nThis is intended to be completely automated; it doesn't need to take any input other than initial settings configuration.\nYou'll be able to leave the window running in the background, and not need to think about it.\n\n## Requirements\n\n+ Python 3.7+\n+ discum 1.3+ (no longer maintained)\n+ discord.py-self\n\n# Configuration\nTo configure the bot, you'll edit the variables in the **Settings_Mudae.json** file for your botting needs.\n\n## Bot settings\nAll settings are set within the Settings_Mudae.json File\n\n+ `token` - The user token for the account you want to bot on. If you need extra assistance on how to obtain it, let me know.\n+ `channelids` - Which channels to **roll** and **monitor**  e.g. 807##########948\n+ `slash_ids` - Which channels to **Slash roll** e.g. 807##########948 (Please Match Slash_id with slash_guild_id)\n+ `slash_guild_ids` - Which Guild to **Slash roll** e.g. 807##########948 (Please Match Guild id with Slash_id)\n+ `claim_delay` - _Affects servers w/o $setting instance_ Time in **seconds** to wait before attempting to Claim Characters e.g. 5\n+ `kak_delay` - _Affects servers w/o $setting instance_ Time in **seconds** to wait before attempting to snipe Kakeraloot e.g. 8\n+ `use_emoji` - This setting only works if you change the Mudaebot.py code by uncommenting out the line (Custom emojis only) e.g.  \"<:emoji_name:795############214>\"\n+ `roll_this` - ($m|$ma|$mg|$w|$wg|$wa|$h|$ha|$hg) If `Rolling` is enabled it will roll this specific command e.g. '$wg'\n+ `Rolling` - (True|False) **Case-sensitive**, uses `channelid`\n+ `slash Rolling` - (True|False) **Case-sensitive**, uses `Slash_ids`\n+ `PkmRolling` - (True|False) Pokeslot rolling enabled, uses `channelid`\n+ `series_list` - **Case-sensitive** Name of series of characters you want to claim  e.g. \\[ \"Honkai Impact 3rd\" , \"Senran Kagura\" \\]\n+ `name_list` - **Must be exact match** List of specific character names to claim  e.g. \\[\"Raiden Mei\", \"gOkU\" \\]\n+ `emoji_list` - This is the kakera that will be snipes \\[ \"KakeraY\" , \"KakeraO\" \\] << This example means only snipe Yellow and orange Kakera\n+ `min_kak` - A minimum kakera value to snipe a claimable character _regardless of whether it's in the series/name lists_\n+ `Last_True` -  (True|False) enable Last Minute Claim windows\n+ `last_claim_min` - (1-180) the window the window is open for e.g. 10 means last 10 minutes\n+ `min_kak_last_min` - same as min kak but only within the last minute claim window\n\n# Optimize the snipes\nTyping $settings in your server with mudae should give you the snipe and kaksnipping timers.\nUsing these values you usually snipes faster than a \"Human\" user can react \n\nPlease when settings Delays avoid setting 0 as your delay as it might be to fast for mudae\na minimum of 1 second to let mudae register that a character was rolled as is reacted to.\n\n# Use at your own Risk\nThis is a Discord **selfbot**. I am not responsible if you get banned using this program. \n\n# Closing Notes\nI understand that this readme is not as detailed as many would like and I'm sure there are many more questions that one may have.\n\nCurrently I'm still supporting this repo so feel free to **Contact Me** if you are having any Issues (Setup , Bugs , Feature suggestions)\n\nAs for updates those will be added up until I no longer feel like this project is fun.\n\nThanks to:\nhttps://github.com/FatPain\nfor Assisting with Discum it was definitly not something I'm use to\n\n","size_bytes":6720},"SECURITY_SETUP.md":{"content":"# Security Setup Instructions\n\n## IMPORTANT: Discord Token Configuration\n\n⚠️ **SECURITY WARNING**: This bot requires your Discord user token to function. Never commit your real token to Git!\n\n### Setup Steps:\n\n1. **Get your Discord token**:\n   - Open Discord in your browser\n   - Press F12 to open Developer Tools\n   - Go to Network tab\n   - Send a message in any channel\n   - Look for a request to `messages` \n   - In the Headers, find `authorization` - that's your token\n\n2. **Configure the bot**:\n   - Copy `Settings_Mudae_TEMPLATE.json` to `Settings_Mudae.json`\n   - Replace `YOUR_DISCORD_USER_TOKEN_HERE` with your real Discord token\n   - Update channel IDs and guild IDs with your server's actual IDs\n   - Configure your desired character names, series, and kakera settings\n\n3. **Channel/Guild ID Setup**:\n   - Enable Developer Mode in Discord (Settings > Advanced > Developer Mode)\n   - Right-click on channels/servers to copy their IDs\n   - Update the following in Settings_Mudae.json:\n     - `channel_ids`: Channels where the bot will roll and monitor\n     - `slash_ids`: Channels for slash commands  \n     - `slash_guild_ids`: Guild IDs for slash commands\n\n### Available Bot Versions:\n\n- **mudaebot3.py**: Uses discord.py-self (recommended, more stable)\n- **MudaeAutoBot.py**: Uses discum library (legacy, more complex)\n\n### Risk Warning:\n\nThis is a Discord selfbot. Using selfbots violates Discord's Terms of Service and may result in account suspension. Use at your own risk.","size_bytes":1491},"mudae_discord_bot.py":{"content":"import discord\nfrom discord.ext import commands\nimport json\nimport re\nimport asyncio\nimport logging\nimport time\nfrom collections import OrderedDict\n\n# Setup logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# Load settings\nwith open(\"Settings_Mudae.json\") as jsonf:\n    settings = json.load(jsonf)\n\n# Bot setup\nintents = discord.Intents.default()\nintents.message_content = True\nintents.guilds = True\nintents.guild_messages = True\n\nbot = commands.Bot(command_prefix='!', intents=intents)\n\n# Mudae constants\nMUDAE_ID = 432610292342587392\n\n# Regex patterns for parsing Mudae messages\nkak_finder = re.compile(r'\\*\\*??([0-9]+)\\*\\*<:kakera:469835869059153940>')\nlike_finder = re.compile(r'Likes\\: \\#??([0-9]+)')\nclaim_finder = re.compile(r'Claims\\: \\#??([0-9]+)')\npagination_finder = re.compile(r'\\d+ / \\d+')\n\nclass MudaeHelper:\n    def __init__(self):\n        self.series_list = settings.get(\"series_list\", [])\n        self.namelist = [name.lower() for name in settings.get(\"namelist\", [])]\n        self.emoji_list = settings.get(\"emoji_list\", [])\n        self.min_kak = settings.get(\"min_kak\", 0)\n    \n    def get_kakera_value(self, text):\n        \"\"\"Calculate kakera value from Mudae message\"\"\"\n        k_value = kak_finder.findall(text)\n        like_value = like_finder.findall(text)\n        claim_value = claim_finder.findall(text)\n        \n        if len(k_value):\n            return int(k_value[0])\n        elif len(like_value) or len(claim_value):\n            LR = int(like_value[0]) if like_value else 0\n            CR = int(claim_value[0]) if claim_value else 0\n            CA = 1\n            pkak = (LR + CR) / 2\n            multi = 1 + (CA / 5500)\n            return int((25000 * (pkak + 70) ** -0.75 + 20) * multi + 0.5)\n        return 0\n    \n    def is_rolled_char(self, message):\n        \"\"\"Check if message is a valid Mudae character roll\"\"\"\n        if not message.embeds:\n            return False\n        \n        embed = message.embeds[0]\n        if not embed.image or not embed.author:\n            return False\n        \n        # Check for pagination (not a roll)\n        if embed.footer and pagination_finder.search(str(embed.footer.text)):\n            return False\n        \n        return True\n\nmudae_helper = MudaeHelper()\n\n@bot.event\nasync def on_ready():\n    logger.info(f'{bot.user} has connected to Discord!')\n    logger.info(f'Bot is in {len(bot.guilds)} guilds')\n    \n    # Sync slash commands\n    try:\n        synced = await bot.tree.sync()\n        logger.info(f'Synced {len(synced)} slash commands')\n    except Exception as e:\n        logger.error(f'Failed to sync commands: {e}')\n\n@bot.event\nasync def on_message(message):\n    # Don't respond to bot messages\n    if message.author.bot:\n        return\n    \n    # Process commands\n    await bot.process_commands(message)\n    \n    # Monitor Mudae rolls for analysis\n    if message.author.id == MUDAE_ID and mudae_helper.is_rolled_char(message):\n        await analyze_mudae_roll(message)\n\nasync def analyze_mudae_roll(message):\n    \"\"\"Analyze a Mudae character roll and provide information\"\"\"\n    if not message.embeds:\n        return\n    \n    embed = message.embeds[0]\n    char_name = embed.author.name if embed.author else \"Unknown\"\n    description = embed.description or \"\"\n    \n    # Calculate kakera value\n    kak_value = mudae_helper.get_kakera_value(description)\n    \n    # Check if character is in wishlist\n    is_wished = char_name.lower() in mudae_helper.namelist\n    \n    # Check if series is wanted\n    wanted_series = any(series in description for series in mudae_helper.series_list)\n    \n    # Send analysis if notable\n    if is_wished or wanted_series or kak_value >= mudae_helper.min_kak:\n        analysis = f\"📊 **Character Analysis**\\n\"\n        analysis += f\"**{char_name}**\\n\"\n        analysis += f\"💎 Kakera Value: {kak_value}\\n\"\n        \n        if is_wished:\n            analysis += \"⭐ This character is on your wishlist!\\n\"\n        if wanted_series:\n            analysis += \"📺 This character is from a wanted series!\\n\"\n        if kak_value >= mudae_helper.min_kak:\n            analysis += f\"💰 High value character (≥{mudae_helper.min_kak})!\\n\"\n        \n        await message.channel.send(analysis)\n\n# Slash Commands\n@bot.tree.command(name=\"mudae-roll\", description=\"Roll for characters in Mudae\")\nasync def mudae_roll(interaction: discord.Interaction, command: str = \"w\"):\n    \"\"\"Roll characters using Mudae commands\"\"\"\n    valid_commands = [\"w\", \"wg\", \"wa\", \"h\", \"hg\", \"ha\", \"m\", \"mg\", \"ma\"]\n    \n    if command not in valid_commands:\n        await interaction.response.send_message(\n            f\"Invalid command. Valid options: {', '.join(valid_commands)}\", \n            ephemeral=True\n        )\n        return\n    \n    # Send the Mudae command\n    await interaction.response.send_message(f\"Rolling with `${command}`...\")\n    await interaction.followup.send(f\"${command}\")\n\n@bot.tree.command(name=\"mudae-wishlist\", description=\"Manage your Mudae wishlist\")\nasync def mudae_wishlist(interaction: discord.Interaction, action: str, character: str = \"\"):\n    \"\"\"Manage wishlist\"\"\"\n    if action == \"add\" and character:\n        if character.lower() not in mudae_helper.namelist:\n            mudae_helper.namelist.append(character.lower())\n            await interaction.response.send_message(f\"✅ Added **{character}** to wishlist!\")\n        else:\n            await interaction.response.send_message(f\"**{character}** is already on your wishlist!\", ephemeral=True)\n    \n    elif action == \"remove\" and character:\n        if character.lower() in mudae_helper.namelist:\n            mudae_helper.namelist.remove(character.lower())\n            await interaction.response.send_message(f\"❌ Removed **{character}** from wishlist!\")\n        else:\n            await interaction.response.send_message(f\"**{character}** is not on your wishlist!\", ephemeral=True)\n    \n    elif action == \"list\":\n        if mudae_helper.namelist:\n            wishlist = \"\\n\".join([f\"• {name.title()}\" for name in mudae_helper.namelist])\n            embed = discord.Embed(title=\"📝 Your Mudae Wishlist\", description=wishlist, color=0x00ff00)\n            await interaction.response.send_message(embed=embed)\n        else:\n            await interaction.response.send_message(\"Your wishlist is empty!\", ephemeral=True)\n    \n    else:\n        await interaction.response.send_message(\n            \"Usage: `/mudae-wishlist add <character>`, `/mudae-wishlist remove <character>`, or `/mudae-wishlist list`\", \n            ephemeral=True\n        )\n\n@bot.tree.command(name=\"mudae-series\", description=\"Manage wanted series\")\nasync def mudae_series(interaction: discord.Interaction, action: str, series: str = \"\"):\n    \"\"\"Manage wanted series\"\"\"\n    if action == \"add\" and series:\n        if series not in mudae_helper.series_list:\n            mudae_helper.series_list.append(series)\n            await interaction.response.send_message(f\"✅ Added **{series}** to wanted series!\")\n        else:\n            await interaction.response.send_message(f\"**{series}** is already in your wanted series!\", ephemeral=True)\n    \n    elif action == \"remove\" and series:\n        if series in mudae_helper.series_list:\n            mudae_helper.series_list.remove(series)\n            await interaction.response.send_message(f\"❌ Removed **{series}** from wanted series!\")\n        else:\n            await interaction.response.send_message(f\"**{series}** is not in your wanted series!\", ephemeral=True)\n    \n    elif action == \"list\":\n        if mudae_helper.series_list:\n            series_list = \"\\n\".join([f\"• {series}\" for series in mudae_helper.series_list])\n            embed = discord.Embed(title=\"📺 Your Wanted Series\", description=series_list, color=0x0099ff)\n            await interaction.response.send_message(embed=embed)\n        else:\n            await interaction.response.send_message(\"You have no wanted series!\", ephemeral=True)\n    \n    else:\n        await interaction.response.send_message(\n            \"Usage: `/mudae-series add <series>`, `/mudae-series remove <series>`, or `/mudae-series list`\", \n            ephemeral=True\n        )\n\n@bot.tree.command(name=\"mudae-config\", description=\"View current Mudae configuration\")\nasync def mudae_config(interaction: discord.Interaction):\n    \"\"\"Show current configuration\"\"\"\n    embed = discord.Embed(title=\"⚙️ Mudae Bot Configuration\", color=0xff9900)\n    embed.add_field(name=\"Min Kakera Value\", value=mudae_helper.min_kak, inline=True)\n    embed.add_field(name=\"Wishlist Count\", value=len(mudae_helper.namelist), inline=True)\n    embed.add_field(name=\"Wanted Series Count\", value=len(mudae_helper.series_list), inline=True)\n    \n    if mudae_helper.namelist:\n        wishlist_preview = \", \".join(mudae_helper.namelist[:5])\n        if len(mudae_helper.namelist) > 5:\n            wishlist_preview += f\" (+{len(mudae_helper.namelist)-5} more)\"\n        embed.add_field(name=\"Wishlist Preview\", value=wishlist_preview, inline=False)\n    \n    if mudae_helper.series_list:\n        series_preview = \", \".join(mudae_helper.series_list[:3])\n        if len(mudae_helper.series_list) > 3:\n            series_preview += f\" (+{len(mudae_helper.series_list)-3} more)\"\n        embed.add_field(name=\"Series Preview\", value=series_preview, inline=False)\n    \n    await interaction.response.send_message(embed=embed)\n\n# Prefix Commands (alternative to slash commands)\n@bot.command(name=\"roll\")\nasync def roll_command(ctx, cmd: str = \"w\"):\n    \"\"\"Roll for characters using prefix command\"\"\"\n    valid_commands = [\"w\", \"wg\", \"wa\", \"h\", \"hg\", \"ha\", \"m\", \"mg\", \"ma\"]\n    \n    if cmd not in valid_commands:\n        await ctx.send(f\"Invalid command. Valid options: {', '.join(valid_commands)}\")\n        return\n    \n    await ctx.send(f\"${cmd}\")\n\n@bot.command(name=\"help-mudae\")\nasync def help_mudae(ctx):\n    \"\"\"Show help for Mudae commands\"\"\"\n    help_text = \"\"\"\n🎮 **Mudae Discord Bot Commands**\n\n**Slash Commands:**\n• `/mudae-roll <command>` - Roll characters (w, wg, wa, h, hg, ha, m, mg, ma)\n• `/mudae-wishlist add/remove/list <character>` - Manage your wishlist\n• `/mudae-series add/remove/list <series>` - Manage wanted series\n• `/mudae-config` - View current configuration\n\n**Prefix Commands:**\n• `!roll <command>` - Roll characters\n• `!help-mudae` - Show this help message\n\n**Features:**\n• 📊 Automatic character analysis\n• 💎 Kakera value calculation\n• ⭐ Wishlist notifications\n• 📺 Series tracking\n\"\"\"\n    \n    embed = discord.Embed(title=\"🎮 Mudae Bot Help\", description=help_text, color=0x00ff00)\n    await ctx.send(embed=embed)\n\n# Run the bot\nif __name__ == \"__main__\":\n    bot.run(settings['token'])","size_bytes":10691},"mudaebot3.py":{"content":"import discord\r\nimport re\r\nimport asyncio\r\nimport json\r\nimport time\r\nimport logging\r\nimport threading\r\nfrom os.path import join as pathjoin\r\nfrom collections import OrderedDict\r\n\r\nclass CacheDict(OrderedDict):\r\n    def __init__(self, *args, **kwds):\r\n        self.max = kwds.pop(\"max\", None)\r\n        OrderedDict.__init__(self, *args, **kwds)\r\n        self._check_size_limit()\r\n\r\n    def __setitem__(self, key, value):\r\n        OrderedDict.__setitem__(self, key, value)\r\n        self._check_size_limit()\r\n\r\n    def _check_size_limit(self):\r\n        if self.max is not None:\r\n            while len(self) > self.max:\r\n                self.popitem(last=False)\r\n\r\nmsg_buf = CacheDict(max=50)\r\n\r\njsonf = open(\"Settings_Mudae.json\")\r\nsettings = json.load(jsonf)\r\njsonf.close()\r\n\r\n\r\nmudae = 432610292342587392\r\nuse_emoji = \"❤️\"\r\n\r\nwith open(\"cmds.txt\",\"r\") as f:\r\n    mudae_cmds = [line.rstrip() for line in f]\r\nmhids = [int(mh) for mh in settings[\"channel_ids\"]]\r\nshids = [int(sh) for sh in settings[\"slash_ids\"]]\r\nghids = [int(gh) for gh in settings[\"slash_guild_ids\"]]\r\nchannel_settings = dict()\r\n\r\nseries_list = settings[\"series_list\"]\r\nchars = [charsv.lower() for charsv in settings[\"namelist\"]]\r\nkak_min = settings[\"min_kak\"]\r\nroll_prefix = settings[\"roll_this\"]\r\nsniping = settings.get(\"sniping_enabled\",True)\r\n\r\n\r\nmention_finder = re.compile(r'\\<@(?:!)?(\\d+)\\>')\r\npagination_finder = re.compile(r'\\d+ / \\d+')\r\n\r\nkak_finder = re.compile(r'\\*\\*??([0-9]+)\\*\\*<:kakera:469835869059153940>')\r\nlike_finder = re.compile(r'Likes\\: \\#??([0-9]+)')\r\nclaim_finder = re.compile(r'Claims\\: \\#??([0-9]+)')\r\npoke_finder = re.compile(r'\\*\\*(?:([0-9+])h )?([0-9]+)\\*\\* min')\r\nwait_finder = re.compile(r'\\*\\*(?:([0-9+])h )?([0-9]+)\\*\\* min \\w')\r\nwaitk_finder = re.compile(r'\\*\\*(?:([0-9+])h )?([0-9]+)\\*\\* min')\r\nser_finder = re.compile(r'.*.')\r\n\r\nKakeraVari = [kakerav.lower() for kakerav in settings[\"emoji_list\"]]\r\n#soulLink = [\"kakeraR\",\"KakeraO\"]\r\neventlist = [\"🕯️\",\"😆\"]\r\n\r\n#Last min Claims\r\nis_last_enable = True if settings[\"Last_True\"].lower().strip() == \"true\" else False \r\nlast_claim_window = settings[\"last_claim_min\"]\r\nmin_kak_last = settings[\"min_kak_last_min\"]\r\n\r\nkakera_wall = {}\r\nwaifu_wall = {}\r\n\r\n#logging settings\r\nlogger = logging.getLogger(__name__)\r\nlogger.setLevel(logging.INFO)\r\nformatter = logging.Formatter('%(asctime)s:%(message)s')\r\nstream_handler = logging.StreamHandler()\r\nstream_handler.setFormatter(formatter)\r\nlogger.addHandler(stream_handler)\r\n\r\ndefault_settings_if_no_settings = f\"\"\"🛠️ __**Server Settings**__ 🛠️\r\n                 (Server not premium)\r\n\r\n                · Prefix: **$** ($prefix)\r\n                · Lang: **en** ($lang)\r\n                · Claim reset: every **180** min. ($setclaim)\r\n                · Exact minute of the reset: xx:**56** ($setinterval)\r\n                · Reset shifted: by +**0** min. ($shifthour)\r\n                · Rolls per hour: **10** ($setrolls)\r\n                · Time before the claim reaction expires: **30** sec. ($settimer)\r\n                · Spawn rarity multiplicator for already claimed characters: **2** ($setrare)\r\n                · Server game mode: **1** ($gamemode)\r\n                · This channel instance: **1** ($channelinstance)\r\n                · Slash commands: enabled ($toggleslash)\r\n\r\n                · Ranking: enabled ($toggleclaimrank/$togglelikerank)\r\n                · Ranks displayed during rolls: claims and likes ($togglerolls)\r\n                · Hentai series: enabled ($togglehentai)\r\n                · Disturbing imagery series: enabled ($toggledisturbing)\r\n                · Rolls sniping: **2** ($togglesnipe) => **8** sec.\r\n                · Kakera sniping: **1** ($togglekakerasnipe) => **8** sec.\r\n                · Limit of characters per harem: **8100** ($haremlimit)\r\n                · Custom reactions: yes ($claimreact list)\r\n\r\n                · Kakera trading: **disabled** ($togglekakeratrade)\r\n                · Kakera calculation: claims and likes ranks (and number of claimed characters) ($togglekakeraclaim/$togglekakeralike)\r\n                · Kakera value displayed during rolls: enabled ($togglekakerarolls)\r\n                · $kakeraloot wishprotect: enabled ($togglewishprotect)\"\"\"            \r\n\r\ndef get_wait(text):\r\n    waits = wait_finder.findall(text)\r\n    if len(waits):\r\n        hours = int(waits[0][0]) if waits[0][0] != '' else 0\r\n        return (hours*60+int(waits[0][1]))*60\r\n    return 0\r\ndef get_pwait(text):\r\n    waits = poke_finder.findall(text)\r\n    if len(waits):\r\n        hours = int(waits[0][0]) if waits[0][0] != '' else 0\r\n        return (hours*60+int(waits[0][1]))*60\r\n    return 0\r\n    \r\ndef parse_settings_message(message):\r\n    if message == None:\r\n        return None\r\n    val_parse = re.compile(r'\\*\\*(\\S+)\\*\\*').findall\r\n    num_parse = re.compile(r'(\\d+)').findall\r\n    num_parsedec = re.compile(r'(\\d*[.,]?\\d+)').findall\r\n\r\n    settings_p = re.findall(r'\\w+: (.*)',message)\r\n    settings = dict()\r\n\r\n    settings['prefix'] = val_parse(settings_p[0])[0]\r\n    settings['prefix_len'] = len(settings['prefix'])\r\n    settings['claim_reset'] = int(num_parse(settings_p[2])[0]) # in minutes\r\n    settings['reset_min'] = int(num_parse(settings_p[3])[0])\r\n    settings['shift'] = int(num_parse(settings_p[4])[0])\r\n    settings['max_rolls'] = int(num_parse(settings_p[5])[0])\r\n    settings['expiry'] = float(num_parse(settings_p[6])[0])\r\n    settings['claim_snipe'] = [float(v) for v in num_parsedec(settings_p[17])]\r\n    settings['kak_snipe'] = [float(v) for v in num_parsedec(settings_p[18])]\r\n    \r\n\r\n    settings['claim_snipe'][0] = int(settings['claim_snipe'][0])\r\n    # pad out claim/kak snipe for default '0 second cooldown'\r\n    if len(settings['claim_snipe']) < 2:\r\n        settings['claim_snipe'] += [0.0]\r\n    if len(settings['kak_snipe']) < 2:\r\n        settings['kak_snipe'] += [0.0]\r\n    settings['claim_snipe'][0] = int(settings['claim_snipe'][0])\r\n    settings['kak_snipe'][0] = int(settings['kak_snipe'][0])\r\n\r\n    settings['pending'] = None\r\n    settings['rolls'] = 0\r\n \r\n    return settings\r\n    \r\ndef get_snipe_time(channel,rolled,message,botter):\r\n    # Returns delay for when you are able to snipe a given roll\r\n    r,d = channel_settings[channel]['claim_snipe']\r\n    if r == 0:\r\n        # Anarchy FTW!\r\n        return 0.0\r\n    \r\n    global user\r\n\r\n    is_roller = (rolled == botter.user.id)\r\n    print(is_roller)\r\n    \r\n    if (r < 4 or r == 5) and is_roller:\r\n        # Roller can insta-snipe\r\n        return 0.0\r\n    if r == 2 and not is_roller:\r\n        # Not the roller.\r\n        return d\r\n    \r\n    wished_for = mention_finder.findall(message)\r\n    \r\n    # Wish-based rules\r\n    if not len(wished_for):\r\n        # Not a WISHED character\r\n        if r > 4:\r\n            # Combined restriction, roller still gets first dibs\r\n            return 0.0 if is_roller else d\r\n        return 0.0\r\n\r\n    if r > 2 and user['id'] in wished_for:\r\n        # Wishers can insta-snipe\r\n        return 0.0\r\n    \r\n    if r == 1 and rolled not in wished_for:\r\n        # Roller (who is not us) did not wish for char, so can insta-snipe\r\n        return 0.0\r\n    \r\n    return d\r\n\r\n    wished_for = mention_finder.findall(message)\r\n    \r\n    # Wish-based rules\r\n    if not len(wished_for):\r\n        # Not a WISHED character\r\n        if r > 4:\r\n            # Combined restriction, roller still gets first dibs\r\n            return 0.0 if is_roller else d\r\n        return 0.0\r\n\r\n    if r > 2 and user['id'] in wished_for:\r\n        # Wishers can insta-snipe\r\n        return 0.0\r\n    \r\n    if r == 1 and rolled not in wished_for:\r\n        # Roller (who is not us) did not wish for char, so can insta-snipe\r\n        return 0.0\r\n    \r\n    return d   \r\n    \r\n    \r\ndef snipe(recv_time,snipe_delay):\r\n    if snipe_delay != 0.0:\r\n        try:\r\n            time.sleep((recv_time+snipe_delay)-time.time())\r\n        except ValueError:\r\n            # sleep was negative, so we're overdue!\r\n            return\r\n    time.sleep(.5)\r\n    \r\ndef is_rolled_char(m):\r\n    # Check if message has embeds\r\n    if not m.embeds:\r\n        return False\r\n\r\n    # Convert the first embed to a dictionary\r\n    embed = m.embeds[0].to_dict()\r\n\r\n    # Check if the embed contains the necessary keys\r\n    if \"image\" not in embed or \"author\" not in embed or list(embed.get(\"author\", {}).keys()) != ['name']:\r\n        # Not a valid roll if no image or author or if author keys don't match\r\n        return False\r\n\r\n    # Check if there's a footer with pagination, which would indicate it's not a roll\r\n    if \"footer\" in embed and \"text\" in embed[\"footer\"]:\r\n        if pagination_finder.findall(embed[\"footer\"][\"text\"]):\r\n            # Pagination found, not a roll\r\n            return False\r\n\r\n    # All checks passed, it seems to be a valid roll\r\n    return True\r\n\r\nclass MyClient(discord.Client):\r\n\r\n    async def bg_task(self,taskid):\r\n        rollingchannel = self.get_channel(taskid)\r\n        wait = 0\r\n        retries = 0\r\n        c_settings = channel_settings[taskid]\r\n        roll_cmd = c_settings['prefix'] + roll_prefix\r\n        def msg_check(message):\r\n            return message.author.id == mudae and message.channel.id == taskid\r\n        \r\n        def quiet_channel_check(message):\r\n            return message.channel.id == taskid and message.author.bot is False\r\n            \r\n        while True:\r\n            \r\n            # Wait for a quiet Moment\r\n            try:\r\n                print(f\"Checking if channel is quiet...\")\r\n                await self.wait_for('message',timeout=60.0,check=quiet_channel_check)\r\n                print(f\"Activity Detected in channel {taskid} from users. delaying rolls\")\r\n                continue\r\n            except asyncio.TimeoutError:\r\n                print(f\"No user Activity in channel {taskid} proceeding rolls\")\r\n            # Rolling Process     \r\n            while wait == 0:\r\n                wait_for_mudae = self.loop.create_task(self.wait_for('message',timeout=10.0,check=msg_check))\r\n                await asyncio.sleep(2)\r\n                await rollingchannel.send(roll_cmd)\r\n                try:\r\n                    msg = await wait_for_mudae\r\n                    if msg.content.startswith(f\"**{self.user.name}\"):\r\n                        \r\n                        wait = get_wait(msg.content)\r\n                        print(wait)\r\n                        retries = 0\r\n                        \r\n                except asyncio.TimeoutError:\r\n                    retries += 1\r\n                    print(f\"Timeout no Response Retrying attempt {retries} max: 5 in 60 sec \")\r\n                    if retries >= 5:\r\n                        print(f\"The Automated rolling on channelid {taskid} is ded. Requires Restart of the program\")\r\n                        return\r\n                    await asyncio.sleep(60)\r\n            await asyncio.sleep(wait)\r\n            wait = 0\r\n\r\n    \r\n    async def on_ready(self):\r\n        print(f'Logged on as {self.user}!')\r\n        \r\n        for xchan in mhids:\r\n            loochannel = self.get_channel(xchan)\r\n            print(loochannel)\r\n            loohistory = await discord.utils.find(lambda m: m.author.id == mudae and \"togglehentai\" in m.content, loochannel.history(limit=100))\r\n            print(loohistory)\r\n            if loohistory != None:\r\n                looc_settings = parse_settings_message(loohistory.content)\r\n            else:\r\n                looc_settings = parse_settings_message(default_settings_if_no_settings)\r\n            channel_settings[xchan] = looc_settings\r\n            \r\n        channel = self.get_channel(807061915515093023)\r\n        historyc = await discord.utils.find(lambda m: m.author.id == mudae and \"togglehentai\" in m.content, channel.history(limit=None))\r\n        print(parse_settings_message(historyc.content))\r\n        c_settings = parse_settings_message(historyc.content)\r\n        dc_settings = parse_settings_message(default_settings_if_no_settings)\r\n        channel_settings[123] = dc_settings\r\n        channel_settings[807061315792928948] = c_settings\r\n            \r\n        print(channel_settings)    \r\n        #self.loop.create_task(self.bg_task(807061315792928948))\r\n        \r\n        \r\n        \r\n        \r\n\r\n    async def on_message(self, message):\r\n        recv=time.time()\r\n        #Don't Message Self\r\n        if message.author == self.user:\r\n            pass\r\n            \r\n        #We don't Have settings in the channel_settings so Skip    \r\n        if int(message.channel.id) not in channel_settings:\r\n            return\r\n            \r\n        c_settings = channel_settings[message.channel.id]\r\n        \r\n        if c_settings['pending'] is None and message.author.id != mudae and message.content[0:c_settings['prefix_len']] == c_settings['prefix'] and message.content.split(' ')[0][c_settings['prefix_len']:] in mudae_cmds:\r\n            c_settings['pending'] = message.author.id\r\n            return\r\n        \r\n        #Interact with Mudae only\r\n        if message.author.id == mudae:\r\n            \r\n            \r\n            if message.interaction is None:\r\n                ineractio = c_settings['pending']\r\n            else:\r\n                ineractio = message.interaction.user.id\r\n            c_settings['pending'] = None\r\n                \r\n            msg_buf[message.id] = {'claimed':(int(message.embeds[0].color) if message.embeds else None) not in (16751916,1360437),'rolled':ineractio == int(message.author.id)}\r\n            \r\n            print(f\"Our user rolled in {message.channel.id}\" if ineractio == self.user.id else f\"Someone else rolled in {message.channel}\")\r\n\r\n            if message.embeds != []:\r\n                try:\r\n                    snipe_delay = get_snipe_time(message.channel.id,ineractio,message.content,self)\r\n                except KeyError:\r\n                    snipe_delay = get_snipe_time(123,ineractio,message.content,self)\r\n                \r\n                if not is_rolled_char(message):\r\n                    pass\r\n                \r\n             \r\n                objects = message.embeds[0].to_dict()\r\n                #Set up Charname\r\n                if 'author' in objects.keys():\r\n                    charname = objects['author']['name']\r\n                else:\r\n                    charname = \"jkqemnxcv not found\"\r\n\r\n                if str(self.user.id) in message.content or \"Wished\" in message.content:\r\n                    print(f\"Wished {objects['author']['name']} in {message.channel.id}: {message.channel.name} \")\r\n                    emoji = use_emoji\r\n                    snipe(recv,snipe_delay)\r\n                    if message.components == []:\r\n                        if message.reactions != [] and not message.reactions[0].custom_emoji:\r\n                            emoji = message.reactions[0].emoji\r\n                            await message.add_reaction(emoji)\r\n                            logger.info(f\"Reaction added on {charname} \")\r\n                    else:\r\n                        await message.components[0].children[0].click()\r\n                        logger.info(f\"Button Clicked on {charname}\")\r\n                           \r\n                #Series Sniping\r\n                for ser in series_list:\r\n                    if ser in objects['description'] and objects['color'] == 16751916:               \r\n                        print(f\"Attempting to Claim {objects['author']['name']} from {ser} in ({message.channel.id}):{message.channel.name}\")\r\n                        emoji = use_emoji\r\n                        snipe(recv,snipe_delay)\r\n                        if message.components == []:\r\n                            if message.reactions != [] and not message.reactions[0].custom_emoji:\r\n                                emoji = message.reactions[0].emoji\r\n                            await message.add_reaction(emoji)\r\n                            break\r\n                        else:\r\n                            await message.components[0].children[0].click()\r\n                            break\r\n                            \r\n                if charname.lower() in chars:\r\n                    logger.info(f\"Character Claim {charname}\")\r\n                    emoji = use_emoji\r\n                    snipe(recv,snipe_delay)\r\n                    if message.components == []:\r\n                        if message.reactions != [] and not message.reactions[0].custom_emoji:\r\n                            emoji = message.reactions[0].emoji\r\n                            await message.add_reaction(emoji)\r\n                    else:\r\n                        await message.components[0].children[0].click()\r\n                    \r\n                            \r\n                #Kakera Sniping            \r\n                if message.components != [] and \"kakera\" in message.components[0].children[0].emoji.name:\r\n                   \r\n                    if \"kakeraP\" in message.components[0].children[0].emoji.name:\r\n                        snipe(recv,snipe_delay)\r\n                        await message.components[0].children[0].click()\r\n                    \r\n                   \r\n                    cooldown = kakera_wall.get(message.guild.id,0) - time.time()\r\n                    if cooldown <= 1:\r\n                        logger.info(f\" {message.components[0].children[0].emoji.name} found in: {message.guild.id} awaiting {snipe_delay}\")\r\n                        snipe(recv,snipe_delay)\r\n                        await message.components[0].children[0].click()\r\n                    else:\r\n                        logger.info(f\" Skipped {message.components[0].children[0].emoji.name} Skipped in: {message.guild.id}\")\r\n                    \r\n                    def kak_check(m):\r\n                        return m.author.id == mudae and m.guild.id == message.guild.id\r\n                        \r\n                    wait_for_kak = self.loop.create_task(self.wait_for('message',timeout=10.0,check=kak_check))\r\n                    try:\r\n                        msgk = await wait_for_kak\r\n                        print(msgk)\r\n                    \r\n                        if msgk.content.startswith(f\"**{self.user.name}\"):\r\n                            time_to_kak = waitk_finder.findall(msgk.content)\r\n                        else:\r\n                            time_to_kak = []\r\n                        print(time_to_kak)\r\n\r\n                    except asyncio.TimeoutError:\r\n                        time_to_kak = []\r\n                    \r\n                    if len(time_to_kak):\r\n                        timegetk = (int(time_to_kak[0][0] or \"0\")*60+int(time_to_kak[0][1] or \"0\"))*60\r\n                        logger.info(f\"{timegetk} set for server {message.guild.id}\")\r\n                        kakera_wall[message.guild.id] = timegetk + time.time()\r\n\r\nclient = MyClient()\r\nclient.run(settings['token'])\r\n","size_bytes":18754},"pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"discord-py==2.3.2\",\n    \"discum>=1.4.1\",\n]\n","size_bytes":190},"replit.md":{"content":"# MudaeAutoBot - Replit Setup\n\n## Project Overview\nThis is a **Discord selfbot** for automating interactions with the Mudae Discord bot game. The bot can automatically roll characters, claim waifus/husbandos, and snipe kakera (in-game currency).\n\n**Current State**: ✅ Fully configured and ready to run with proper credentials\n\n## Recent Changes\n- **2025-09-18**: Initial GitHub import setup completed\n- Installed Python 3.11 and all required Discord libraries\n- Fixed JSON configuration format issues\n- Set up security measures for token protection\n- Configured workflow to run the bot\n\n## User Preferences\n- None specified yet\n\n## Project Architecture\n\n### Key Files\n- **launcher.py**: Interactive bot launcher (choose which bot to run)\n- **start.py**: Quick start script (runs recommended bot directly)\n- **mudae_discord_bot.py**: Main bot file using discord.py (RECOMMENDED)\n- **mudaebot3.py**: Alternative bot file using discord.py\n- **MudaeAutoBot.py**: Legacy version using discum library\n- **Settings_Mudae.json**: Configuration file (requires real Discord token)\n- **Settings_Mudae_TEMPLATE.json**: Template for safe configuration sharing\n- **SECURITY_SETUP.md**: Detailed setup instructions and security warnings\n\n### Dependencies\n- Python 3.11\n- discord.py-self: Modern Discord selfbot library\n- discum: Legacy Discord API wrapper\n- Standard JSON/logging libraries\n\n### Configuration\n- Bot requires Discord user token (currently using demo placeholder)\n- Channel IDs and Guild IDs need to be configured for target Discord servers\n- Supports character name lists, series filtering, and kakera sniping\n\n### How to Start Your Bot\n\n**Option 1: Automatic Start (Recommended)**\n- Click the \"Run\" button in Replit\n- The launcher will automatically start the best bot version\n\n**Option 2: Interactive Menu**\n- Run `python3 launcher.py` in the terminal\n- Choose which bot version to run from the menu\n\n**Option 3: Direct Start**\n- Run `python3 start.py` for the recommended bot\n- Or run `python3 mudae_discord_bot.py` directly\n\n### Bot Versions Available\n- **mudae_discord_bot.py**: ✅ Modern, stable (RECOMMENDED)\n- **mudaebot3.py**: Alternative version with discord.py\n- **MudaeAutoBot.py**: Legacy version using discum library\n\n### Workflow\n- **Start application**: Now runs the bot launcher\n- Automatically selects the best working bot version\n- Ready for production use with your Discord token\n\n## Security Notes\n- Discord user token is required but kept secure\n- .gitignore configured to prevent accidental token commits  \n- Template files provided for safe configuration sharing\n- Users warned about Discord ToS violations with selfbots\n\n## Next Steps for Users\n1. Follow SECURITY_SETUP.md to configure Discord token\n2. Update channel/guild IDs for target servers\n3. Customize character lists and kakera settings\n4. Run the workflow to start botting","size_bytes":2860},"run.sh":{"content":"python mudae_discord_bot.py\n","size_bytes":28},"channeldata/explain.md":{"content":"New Folder added for Future Persistant Data\n","size_bytes":44},"proof_of_functionality/test_prof.md":{"content":"# 5/26/2023\npokeroll and daily roll\n\n![image](https://github.com/vivinano/MudaeAutoBot/assets/33008397/2f2665b7-fa4e-4a7e-8517-e61860388c08)\n\nwaifu roll\n\n![image](https://github.com/vivinano/MudaeAutoBot/assets/33008397/0ffb7aa1-9a4f-4089-a1c8-d9d007004528)\n\n![image](https://github.com/vivinano/MudaeAutoBot/assets/33008397/23a55548-5880-44d4-aba9-a859b077ce15)\n\nroll timer waiting\n\n![image](https://github.com/vivinano/MudaeAutoBot/assets/33008397/586ef4b4-8ca3-49b7-a280-43378435a8b2)\n\n\n\n# 2/20/2023\n\nwaifu claim\n\n![image](https://user-images.githubusercontent.com/33008397/220013914-f4d89f06-d0d9-458b-a7e2-cc8a70dac1f3.png)\n\npokeroll\n\n![image](https://user-images.githubusercontent.com/33008397/220014089-e5d62b61-fe3b-45a3-bf23-08e34e113b2e.png)\n\n\nslash roll / button claim test\n\n![image](https://user-images.githubusercontent.com/33008397/220014425-168b25b6-8c7f-4f46-8f73-8795072d94b2.png)\n\n\n\n\n","size_bytes":902},"launcher.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nMudae Bot Launcher\nChoose which bot version to run\n\"\"\"\nimport os\nimport sys\nimport subprocess\n\ndef clear_screen():\n    os.system('cls' if os.name == 'nt' else 'clear')\n\ndef show_menu():\n    clear_screen()\n    print(\"=\" * 50)\n    print(\"    MUDAE DISCORD BOT LAUNCHER\")\n    print(\"=\" * 50)\n    print()\n    print(\"Choose which bot to run:\")\n    print()\n    print(\"1. 🤖 Modern Bot (discord.py) - RECOMMENDED\")\n    print(\"   File: mudae_discord_bot.py\")\n    print(\"   ✅ Stable, well-tested\")\n    print(\"   ✅ Full Discord API support\")\n    print()\n    print(\"2. 🔧 Alternative Bot (discord.py)\")\n    print(\"   File: mudaebot3.py\") \n    print(\"   ⚠️  May have configuration issues\")\n    print()\n    print(\"3. 🛠️  Legacy Bot (discum)\")\n    print(\"   File: MudaeAutoBot.py\")\n    print(\"   ⚠️  Uses older selfbot library\")\n    print(\"   ⚠️  May have compatibility issues\")\n    print()\n    print(\"4. ❌ Exit\")\n    print()\n    print(\"=\" * 50)\n\ndef run_bot(bot_file):\n    print(f\"\\n🚀 Starting {bot_file}...\")\n    print(\"Press Ctrl+C to stop the bot\\n\")\n    try:\n        subprocess.run([sys.executable, bot_file], check=True)\n    except KeyboardInterrupt:\n        print(\"\\n✋ Bot stopped by user\")\n    except subprocess.CalledProcessError as e:\n        print(f\"\\n❌ Bot crashed with error code {e.returncode}\")\n        print(\"Check your Settings_Mudae.json configuration\")\n    except FileNotFoundError:\n        print(f\"\\n❌ File {bot_file} not found\")\n\ndef main():\n    # Check if running in interactive mode\n    if not sys.stdin.isatty():\n        print(\"Non-interactive mode detected. Starting recommended bot...\")\n        run_bot(\"mudae_discord_bot.py\")\n        return\n    \n    while True:\n        show_menu()\n        \n        try:\n            choice = input(\"Enter your choice (1-4): \").strip()\n            \n            if choice == \"1\":\n                run_bot(\"mudae_discord_bot.py\")\n            elif choice == \"2\":\n                run_bot(\"mudaebot3.py\")\n            elif choice == \"3\":\n                run_bot(\"MudaeAutoBot.py\")\n            elif choice == \"4\":\n                print(\"\\n👋 Goodbye!\")\n                break\n            else:\n                input(\"\\n❌ Invalid choice. Press Enter to continue...\")\n                continue\n                \n        except (KeyboardInterrupt, EOFError):\n            print(\"\\n\\n👋 Goodbye!\")\n            break\n        \n        input(\"\\nPress Enter to return to menu...\")\n\nif __name__ == \"__main__\":\n    main()","size_bytes":2513},"replit.toml":{"content":"[deployment]\nrun = [\"python3\", \"launcher.py\"]\n\n[[ports]]\nlocalPort = 5000\nexternalPort = 80\n","size_bytes":92},"start.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nQuick start script for Mudae Discord Bot\nThis will run the recommended bot version directly\n\"\"\"\nimport subprocess\nimport sys\n\ndef main():\n    print(\"🚀 Starting Mudae Discord Bot...\")\n    print(\"📝 Using: mudae_discord_bot.py (recommended version)\")\n    print(\"⚙️  Reading configuration from Settings_Mudae.json\")\n    print()\n    print(\"Bot will start in 3 seconds...\")\n    print(\"Press Ctrl+C to stop the bot\")\n    print(\"=\" * 50)\n    \n    try:\n        subprocess.run([sys.executable, \"mudae_discord_bot.py\"], check=True)\n    except KeyboardInterrupt:\n        print(\"\\n✋ Bot stopped by user\")\n    except subprocess.CalledProcessError as e:\n        print(f\"\\n❌ Bot crashed with error code {e.returncode}\")\n        print(\"💡 Tip: Check your Settings_Mudae.json for correct Discord token\")\n    except FileNotFoundError:\n        print(\"\\n❌ mudae_discord_bot.py not found\")\n\nif __name__ == \"__main__\":\n    main()","size_bytes":951}},"version":1}